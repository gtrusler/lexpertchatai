# Lexpert Case AI - Project Intelligence

This file captures important patterns, preferences, and project intelligence for the Lexpert Case AI project.

## Critical Implementation Paths

1. **Frontend Structure**
   - The main frontend code is in `src/frontend/`, not in the root `src/` directory
   - Always run frontend commands from the `src/frontend/` directory
   - The frontend uses Vite as the build tool, not Create React App

2. **Backend Structure**
   - The backend code is in the root `backend/` directory
   - Always activate the conda environment before running backend commands
   - The backend uses FastAPI with uvicorn as the ASGI server

3. **Environment Management**
   - Always activate the conda environment (`conda activate lexpert_case_ai`) in each new terminal window
   - Frontend and backend should be run in separate terminal windows
   - Environment variables are stored in separate `.env` files for frontend and backend

## User Preferences and Workflow

1. **UI Preferences**
   - Use deep blue (#0078D4) as the primary color
   - Maintain clean, minimal UI with white cards on light gray background
   - Ensure dark mode support with proper contrast
   - Prefer simple, intuitive navigation with minimal clicks

2. **Terminology**
   - Use "assistants" instead of "bots" throughout the application
   - Use "templates" for predefined assistant configurations
   - Use "cases" when referring to legal matters
   - Use clear, non-technical language in the UI

3. **Navigation Patterns**
   - Always provide a way to return to the Dashboard from any screen
   - Include breadcrumb navigation for context
   - Support keyboard shortcuts for common actions
   - Ensure all clickable elements are obviously interactive

## Project-Specific Patterns

1. **Component Structure**
   - Page components are in `src/frontend/src/pages/`
   - Common components are in `src/frontend/src/components/common/`
   - Layout components are in `src/frontend/src/components/layouts/`
   - Feature-specific components are in dedicated subdirectories

2. **State Management**
   - Use React Context for application-wide state (theme, auth)
   - Use local state for component-specific state
   - Use localStorage for persistent preferences (dark mode, voice commands)
   - Plan to implement more robust state management for complex features

3. **Styling Approach**
   - Use Tailwind CSS for styling
   - Follow the class order convention: layout → typography → visual
   - Use dark mode classes with the 'dark:' prefix
   - Maintain consistent spacing and sizing

4. **Error Handling**
   - Log errors to console during development
   - Use try/catch blocks for async operations
   - Provide user-friendly error messages
   - Handle network errors gracefully

## Known Challenges

1. **Navigation Issues**
   - Some clickable elements may not register clicks properly
   - Card components needed explicit pointer-events-auto styling
   - Navigation between components can be inconsistent
   - Ensure proper event handling with stopPropagation and preventDefault

2. **Dark Mode Implementation**
   - Tailwind CSS requires 'class' strategy for dark mode
   - All components must use dark: prefix for dark mode styles
   - ThemeContext must be used consistently across components
   - Some components may not properly respect dark mode settings

3. **Mock Data Limitations**
   - Current implementation uses mock data instead of real backend
   - No persistence of user actions with mock data
   - Mock data doesn't fully represent real-world scenarios
   - Plan to replace with actual Supabase integration

4. **File Structure Confusion**
   - Legacy components exist in `src/components/`
   - Current components are in `src/frontend/src/components/`
   - Maintain clear separation between old and new code
   - Document file locations clearly

## Evolution of Project Decisions

1. **Terminology Change**
   - Initially used "bots" for AI assistants
   - Changed to "assistants" for better user understanding
   - Updated all references in code and UI
   - Maintained backward compatibility in data structures

2. **UI Simplification**
   - Removed redundant title bars
   - Moved control buttons to the top header
   - Simplified the Dashboard layout
   - Added direct navigation buttons for reliability

3. **Theme Implementation**
   - Initially used local state for theme management
   - Migrated to ThemeContext for application-wide state
   - Added localStorage persistence
   - Implemented proper Tailwind configuration

4. **Component Architecture**
   - Started with monolithic components
   - Gradually breaking down into smaller, reusable components
   - Implementing proper separation of concerns
   - Moving toward more maintainable structure

## Tool Usage Patterns

1. **Development Environment**
   - Use VS Code with Cursor for AI-assisted coding
   - Use Chrome DevTools for debugging
   - Use Postman for API testing
   - Use Git for version control

2. **Terminal Commands**
   - Start frontend: `conda activate lexpert_case_ai && cd src/frontend && npm run dev`
   - Start backend: `conda activate lexpert_case_ai && cd backend && uvicorn main:app --reload`
   - Install frontend dependencies: `cd src/frontend && npm install`
   - Install backend dependencies: `cd backend && pip install -r requirements.txt`

3. **Debugging Techniques**
   - Use console.log for frontend debugging
   - Use Chrome DevTools React Developer Tools
   - Use Python debugger for backend
   - Check browser console for errors

4. **Testing Approach**
   - Manual testing of UI components
   - Console.log verification of data flow
   - Planned implementation of automated tests
   - Test on multiple browsers for compatibility

## Special Considerations

1. **Performance Optimization**
   - Minimize re-renders with React.memo and useMemo
   - Use proper key props in lists
   - Implement pagination for large data sets
   - Consider code splitting for larger bundles

2. **Accessibility**
   - Include ARIA labels on all interactive elements
   - Ensure keyboard navigation works properly
   - Maintain proper color contrast
   - Test with screen readers

3. **Mobile Responsiveness**
   - Use responsive Tailwind classes
   - Test on various screen sizes
   - Implement mobile-specific UI adjustments
   - Ensure touch targets are large enough

4. **Security Practices**
   - Never expose API keys in frontend code
   - Implement proper authentication checks
   - Validate all user inputs
   - Follow security best practices for Supabase 